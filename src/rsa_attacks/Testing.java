/**
 * ########################################################
 * 
 * @author: Michael De Angelis
 * @mat: 560049
 * @project: Esperienze di Programmazione [ESP]
 * @AA: 2019 / 2020
 * 
 * ########################################################
 */

package rsa_attacks;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Random;

public class Testing {

	public static void main(String[] args) {
		// Rsa object used to perform the brute force attack and the Fermat factoring attack
		RSA rsaObj = new RSA();
		rsaObj.printInfo();
		
		RsaAttacker.bruteForceAttack(rsaObj.getExponent(), rsaObj.getN());

		RsaAttacker.fermatFactoringAttack(rsaObj.getExponent(), rsaObj.getN());
		System.out.println();
		
		// Simulate an exponent based attack with e = 3;
		int e = 3;
		ArrayList<RSA> rsaObjs = new ArrayList<RSA>();
		BigInteger ee = new BigInteger("3");
		// Create e user with the same exponent and different value of n = p * q
		for(int i = 0; i < e; i++) {
			rsaObjs.add(new RSA(ee));
			rsaObjs.get(i).printInfo();
		}
	
		// Create the list of the components n of the public key of each users
		ArrayList<BigInteger> n = new ArrayList<BigInteger>();
		for(RSA rsa : rsaObjs)
			n.add(rsa.getN());
		
		// Get the minimum n in order to create a message < n (for the modulo reduction)
		BigInteger min = n.get(0);
		for(int i = 1; i < n.size(); i++)
			if(n.get(i).compareTo(min) < 0)
				min = n.get(i);
		
		// Generate a random message less that min
		Random rnd = new Random();
		BigInteger msg;
		do {
			msg = new BigInteger(32, rnd);
		} while(msg.compareTo(min) >= 0);
		
		// Create the list of the cryptograms generated by each user for the same message msg
		ArrayList<BigInteger> c = new ArrayList<BigInteger>();
		for(RSA rsa : rsaObjs)
			c.add(rsa.encrypt(msg));
		
		System.out.println("Original Random Message: " + msg + System.lineSeparator());
		
		RsaAttacker.eSameValueAttack(e, n, c);
		
		// Generate p and q such that p != q
		BigInteger p32Bit = null;
		BigInteger q32Bit = null;
		do {
			p32Bit = BigInteger.probablePrime(32, rnd);
			q32Bit = BigInteger.probablePrime(32, rnd);
		} while(p32Bit.equals(q32Bit));
		
		// Generate two RSA object with the same value of n and different exponents; gcd(e1, e2) must be 1
		RSA rsa1 = null;
		RSA rsa2 = null;
		do {
			rsa1 = new RSA(p32Bit, q32Bit);
			rsa2 = new RSA(p32Bit, q32Bit);
		} while(rsa1.getExponent().equals(rsa2.getExponent()) || 
				!rsa1.getExponent().gcd(rsa2.getExponent()).equals(BigInteger.ONE));
		
		rsa1.printInfo();
		rsa2.printInfo();
		
		// Generate a random message less that rsa1.N and rsa2.N
		do {
			msg = new BigInteger(32, rnd);
		} while(msg.compareTo(rsa1.getN()) >= 0 || msg.compareTo(rsa2.getN()) >= 0);
		
		System.out.println("Original Random Message: " + msg + System.lineSeparator());
		
		RsaAttacker.nSameValueAttack(rsa1.getN(), rsa1.getExponent(), rsa2.getExponent(), rsa1.encrypt(msg), rsa2.encrypt(msg));
	}
}
